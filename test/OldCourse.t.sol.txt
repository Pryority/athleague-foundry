// test/Course.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Course.sol";

contract CourseTest is Test {
    Course course;
    address owner;
    mapping(address => uint256) public cpStartTimes;
    mapping(address => uint256) public cpFinishTimes;

    function setUp() public {
        course = new Course();
        owner = msg.sender;
    }

    function test_AddCheckpoint() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(654, 321);
        course.build();
        Course.Checkpoint[] memory checkpoints = course.getCheckpoints();
        assertEq(checkpoints.length, 2);
        assertEq(checkpoints[0].coord.lat, 123);
        assertEq(checkpoints[0].coord.long, 456);
        assertEq(checkpoints[0].sequence, 0);
    }

    function test_AddCheckpoints() public {
        int256[] memory latitudes = new int256[](3);
        latitudes[0] = 123456;
        latitudes[1] = 234567;
        latitudes[2] = 345678;
        int256[] memory longitudes = new int256[](3);
        longitudes[0] = 987654;
        longitudes[1] = 876543;
        longitudes[2] = 765432;
        course.addCheckpoints(latitudes, longitudes);
        course.build();
        Course.Checkpoint[] memory checkpoints = course.getCheckpoints();
        assertEq(checkpoints.length, 3);
        assertEq(checkpoints[0].coord.lat, latitudes[0]);
        assertEq(checkpoints[0].coord.long, longitudes[0]);
        assertEq(checkpoints[0].sequence, 0);
        assertEq(checkpoints[1].coord.lat, latitudes[1]);
        assertEq(checkpoints[1].coord.long, longitudes[1]);
        assertEq(checkpoints[1].sequence, 1);
        assertEq(checkpoints[2].coord.lat, latitudes[2]);
        assertEq(checkpoints[2].coord.long, longitudes[2]);
        assertEq(checkpoints[2].sequence, 2);
    }

    function test_RemoveCheckpoint() public {
        course.addCheckpoint(123, 456);
        course.removeCheckpoint(0);
        vm.expectRevert("At least two checkpoints must be added.");
        course.build();
    }

    function test_Build() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(101, 202);
        course.build();
        bool built = course.built();
        assertEq(built, true);
    }

    function test_GetCheckpoints() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(789, 101112);
        course.build();
        Course.Checkpoint[] memory checkpoints = course.getCheckpoints();
        assertEq(checkpoints.length, 2);
        assertEq(checkpoints[0].coord.lat, 123);
        assertEq(checkpoints[0].coord.long, 456);
        assertEq(checkpoints[0].sequence, 0);
        assertEq(checkpoints[1].coord.lat, 789);
        assertEq(checkpoints[1].coord.long, 101112);
        assertEq(checkpoints[1].sequence, 1);
    }

    function test_OnlyOwnerModifier() public {
        vm.prank(owner);
        Course otherCourse = new Course();
        course.addCheckpoint(654, 321);
        try otherCourse.addCheckpoint(123, 456) {
            assertTrue(false, "Function should have reverted.");
        } catch Error(string memory reason) {
            assertEq(reason, "Only the owner can perform this operation.");
        } catch {
            assertTrue(false, "Unexpected error.");
        }
        try otherCourse.removeCheckpoint(0) {
            assertTrue(false, "Function should have reverted.");
        } catch Error(string memory reason) {
            assertEq(reason, "Only the owner can perform this operation.");
        } catch {
            assertTrue(false, "Unexpected error.");
        }
        try otherCourse.build() {
            assertTrue(false, "Function should have reverted.");
        } catch Error(string memory reason) {
            assertEq(reason, "Only the owner can perform this operation.");
        } catch {
            assertTrue(false, "Unexpected error.");
        }
    }

    function test_NotBuiltModifier() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(654, 321);
        course.build();
        vm.expectRevert("Course has already been built.");
        course.addCheckpoint(789, 101112);
    }

    // function test_MarkCheckpointCompleted() public {
    //     course.addCheckpoint(123, 456);
    //     course.addCheckpoint(654, 321);
    //     course.build();
    //     vm.prank(owner);
    //     course.startCourse();
    //     course.markCheckpointCompleted(0, owner);
    // }

    function test_MarkCheckpointCompleted() public {
        course.addCheckpoint(1, 1);
        course.addCheckpoint(2, 2);
        course.build();
        bytes
            memory privateKey = hex"ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
        bytes32 signature = course.getMessageHash(
            "I completed checkpoint",
            1,
            1,
            1,
            0
        );
        bytes memory sig = bytes(abi.encodePacked(signature));
        course.markCheckpointCompleted(1, 1, 0, sig);
        Course.Checkpoint memory firstCheckpoint = course.checkpoints(0);
        assertEq(
            firstCheckpoint.completed,
            true,
            "Checkpoint should be marked as completed."
        );
        signature = course.getMessageHash("I completed checkpoint", 2, 2, 2, 1);
        course.markCheckpointCompleted(2, 2, 1, signature);
        Course.Checkpoint memory secondCheckpoint = course.checkpoints(1);
        assertEq(
            secondCheckpoint,
            true,
            "Checkpoint should be marked as completed."
        );
    }

    function test_StartCourse() public {
        assertFalse(course.built());
        course.addCheckpoint(123, 456);
        course.addCheckpoint(654, 321);
        course.build();
        assertTrue(course.built());
        course.startCourse();
        assertEq(cpStartTimes[msg.sender], block.timestamp - 1);
    }

    function test_FinishCourse() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(654, 321);
        course.build();
        assertTrue(course.built());
        vm.startPrank(owner);
        course.startCourse();
        cpStartTimes[msg.sender] = block.timestamp;
        course.markCheckpointCompleted(0, msg.sender);
        course.markCheckpointCompleted(1, msg.sender);
        cpFinishTimes[msg.sender] = block.timestamp;
        assertEq(cpFinishTimes[msg.sender], block.timestamp);
        vm.stopPrank();
    }

    event cpTimes(uint256[]);

    function test_GetCheckpointTimes() public {
        course.addCheckpoint(123, 456);
        course.addCheckpoint(789, 101112);
        course.build();
        vm.startPrank(owner);
        course.startCourse();
        cpStartTimes[msg.sender] = block.timestamp;
        course.markCheckpointCompleted(0, msg.sender);
        course.markCheckpointCompleted(1, msg.sender);
        cpFinishTimes[msg.sender] = block.timestamp;
        uint256[] memory checkpointTimes = course.getCheckpointTimes(
            msg.sender
        );

        emit cpTimes(checkpointTimes);
        uint256 bt = block.timestamp;
        assertEq(bt, cpStartTimes[msg.sender]);
        assertEq(checkpointTimes.length, 2);
        // assertEq(checkpointTimes[0], cpStartTimes[msg.sender] + 1);
        // assertEq(checkpointTimes[1], cpFinishTimes[msg.sender]);
    }

    // function test_GetTotalTime() public {
    //     course.addCheckpoint(123, 456);
    //     course.addCheckpoint(654, 321);
    //     course.build();
    //     course.startCourse();
    //     cpStartTimes[msg.sender] = block.timestamp - 3600;
    //     cpFinishTimes[msg.sender] = cpStartTimes[msg.sender] + 1800;
    //     uint256 totalTime = course.getTotalTime(msg.sender);
    //     assertEq(totalTime, 1800);
    // }
}
